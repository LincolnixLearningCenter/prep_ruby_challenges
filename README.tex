% Created 2016-04-18 Mon 00:54
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\date{\today}
\title{README}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\textbf{prep$_{\text{ruby}}$$_{\text{challenges}}$}

\href{http://www.vikingcodeschool.com/web-markup-and-coding/level-up-your-ruby-judo}{The Ruby challenge problems from the Markup and Coding course of the Viking Code School Prep Work}

\section{Ruby Calisthenics}
\label{sec-1}

\subsection{Power}
\label{sec-1-1}

Write a method \emph{power} which takes two integers (\emph{base} and \emph{exponent}) and 
returns the \emph{base} raised to the power of \emph{exponent}. Do not use Ruby's "**"
operator for this!

\begin{verbatim}
> power(3,4)
=> 81 # (3*3*3*3)
\end{verbatim}

\begin{verbatim}
def power(base,exponent)
  # returns base raised to the power of exponent without the use of ** operator

  a = base
  b = exponent
  c = []

  b.times do
    c.push a
  end

  c.inject(1) {|product, n| product * n}
end

p power(3,4)
\end{verbatim}

\subsection{Factorial}
\label{sec-1-2}

Write a method \emph{factorial} which takes a number and returns the product of 
every number up to the current number multiplied together.

\begin{verbatim}
> factorial(5)
=> 120 # from 1*2*3*4*5
\end{verbatim}

\begin{verbatim}
def factorial(n)
  # Int => Int
  # Takes a number and returns the product of every number up to 
  # the current number multiplied together

  a = []

  n.downto(1).each do |i|
    a.push i
  end

  return a.inject(1) {|product, n| product * n}

end

p factorial(5)
\end{verbatim}

\subsection{Uniques}
\label{sec-1-3}

Write a method \emph{uniques} which takes an array of items and returns the array
without any duplicates. Don't use Ruby's \emph{uniq} method.

\begin{verbatim}
uniques([1,5,"frog",2,1,3,"frog"])
=> [1,5,"frog",2,3]
\end{verbatim}

\begin{verbatim}
def uniques(array)
  # Array of Items => Array of Items
  # Takes an array, returns array with duplicate items removed.
  # Write without uniq

  no_dupes = []
  couples = array.combination(2)
  groups = array.group_by{|e| e}

  groups.each do |g|
    no_dupes.push(g[0])
  end

  return no_dupes
end

p uniques([1,5,"frog",2,1,3,"frog"])
\end{verbatim}

\subsection{Combinations}
\label{sec-1-4}

Write a method \emph{combinations} which takes two arrays of strings and returns
an array with all of the combinations of the items in them, listing the first
items first.

\begin{verbatim}
> combinations(["on","in"],["to","rope"])
=> ["onto","onrope","into","inrope"]
\end{verbatim}

\begin{verbatim}
def combinations(ary1,ary2)
  # Ary(Str), Ary(Str) => Ary(Str)
  # Takes two arrays of strings, returns an array with all of the combinations
  # of the items in them, listing the first item first.

  a = ary1
  b = ary2

  c = []

  a.each do |s|
    b.each do |x|
      c.push "#{s}#{x}"
    end
  end

  p c
end

combinations(["on","in"],["to","rope"])
\end{verbatim}

\subsection{Primes}
\label{sec-1-5}

Write a method \emph{is$_{\text{prime}}$?} which takes in a number and returns \emph{true} if it 
is a prime number.

\begin{verbatim}
> is_prime?(7)
=> true
> is_prime?(14)
=> false
\end{verbatim}

\begin{verbatim}
def is_prime?(i)
  range = (i-1).downto(2)

  range.each do |a|
    #p i%a == 0
  end

  p range.any? {|a| i%a == 0}
end

is_prime?(7)
\end{verbatim}

\subsection{Rectangle Overlap}
\label{sec-1-6}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
